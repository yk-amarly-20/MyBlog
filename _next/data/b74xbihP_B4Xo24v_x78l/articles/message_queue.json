{
  "pageProps": {
    "article": {
      "header": {
        "slug": "message_queue",
        "matter": {
          "title": "Message Queueingについて",
          "createdAt": "2020-05-20T12:13:43.525Z",
          "tags": ["backend", "typescript", "ampqlib"]
        },
        "excerpt": "Message Queueing について Message Queueing とは Message Queueing(以下、MQ)とは、システム上でデータを通信する際の通信方式の一つです。 この方式では、データを送信する際に受信システムに直接送信するのではなく、キューにデータを格納し、受信システムは任意のタイミングでキ..."
      },
      "bodyMdText": "\n# Message Queueing について\n\n## Message Queueing とは\n\nMessage Queueing(以下、MQ)とは、システム上でデータを通信する際の通信方式の一つです。  \nこの方式では、データを送信する際に受信システムに直接送信するのではなく、キューにデータを格納し、受信システムは任意のタイミングでキューからデータを受け取ります。  \nデータ通信では通常、送信側は受信側の状態を、受信側は送信側の状態を確認する必要があります。 この場合、それぞれのシステムに「相手側の状態を確認する機能」を実装する必要が出できてしまいます。\n機能は分散すべき、というシステム開発の基本的な考えによれば、これはあまり芳しくありません。  \n加えて、実装が互いのインターフェース、サーバー性能(処理時間など)に左右されてしまうため、システム全体の独立性が落ちてしまう、という欠点があります。サーバーを更新した際などに実装を\n変更する必要がある、というのも問題点の一つですね。\n\n![without_MQ](/Images/without_queue.png)\n\nそこで、MQ アルゴリズムでは送信サーバーからのデータを「メッセージ」という単位ごとにキューに格納しておき、受信サーバーはキューから好きなタイミングでデータを取り出し、処理します。  \nこれにより、送信サーバーと受信サーバーが直接通信することがなくなり、システム全体の独立性が上がります。 また負荷分散の観点から見てもこのアルゴリズムは優れています。 通常の通信では\n片方のサーバーがサーバー負荷により処理性能が落ちた場合、もう片方の実行にも影響が出ます。ですが、MQ では直接通信が発生しないことにより、片方のサーバーの負荷がもう片方のサーバーの\n処理に影響を与えません。\n\n![MQ](/Images/message_queue.png)\n\n## MQ の実装(amqplib)\n\nでは、MQ を実装してみます。  \nMQ を実装できるオープンソースソフトウェアに「RabbitMQ」があります。 今回は Node.js から RabbitMQ にアクセスしてみます。  \nNode.js から RabbitMQ にアクセスできるライブラリは複数ありますが、今回は「amqplib」を用います。 インストールは以下です。\n\n```sh\nnpm install --save ampqlib\n```\n\nでは、送信側の処理と受信側の処理をそれぞれ実装していきます。\n\n#### 送信側の処理\n\n```tsx\nimport * as ampq from \"amqplib\";\n\nconst QUEUE = \"message-queue\";\n\nfunction wait(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n(async function main() {\n  const connection = await ampq.connect(\n    \"amqp://localhost\",\n    function (error: Error, connection: ampq.Connection) {\n      if (error) {\n        throw error;\n      }\n    },\n  );\n\n  const channel = await connection.createChannel();\n  channel.assertQueue(QUEUE);\n  let send_counter = 0;\n\n  while (send_counter < 100) {\n    const message = `Hello ${send_counter}`;\n    channel.sendToQueue(QUEUE, Buffer.from(message));\n    console.log(\"send \", message);\n    await wait(1500);\n    send_counter++;\n  }\n\n  await channel.close();\n})();\n```\n\nampqlib では、最初に connect()関数で connection を取得してから createChannel などで\nchannel を作成し、channel に実装されたメソッドでクエリを処理します。ここでは channel.sendToQueue メソッドでキューに 100 回メッセージを送信しています。\n\n#### 受信側の実装\n\n```tsx\nimport * as ampq from \"amqplib\";\n\nconst QUEUE = \"message-queue\";\n\nfunction wait(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n(async function main() {\n  const connection = await ampq.connect(\n    \"ampq://localhost\",\n    function (error: Error, connection: ampq.Connection) {\n      if (error) {\n        throw error;\n      }\n    },\n  );\n\n  const channel = await connection.createChannel();\n  await channel.prefetch(1);\n  channel.assertQueue(QUEUE);\n\n  await channel.consume(QUEUE, async function (message) {\n    console.log(\"Receive\");\n    await wait(1500);\n    channel.ack(message);\n  });\n});\n```\n\n受信側は、channel.consume()メソッドを用いることで受信宣言をすることができ、キュー内のメッセージを全て受信した後も\n新たなメッセージを随時取得します。\n\n## おわりに\n\nここで紹介した機能だけだと、様々な要因でシステム障害が発生します。機会があればまたそこについても更新していこうとい思います。\n",
      "tocMdText": "- [Message Queueing について](#message-queueing-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)\n  * [Message Queueing とは](#message-queueing-%E3%81%A8%E3%81%AF)\n  * [MQ の実装(amqplib)](#mq-%E3%81%AE%E5%AE%9F%E8%A3%85amqplib)\n      - [送信側の処理](#%E9%80%81%E4%BF%A1%E5%81%B4%E3%81%AE%E5%87%A6%E7%90%86)\n      - [受信側の実装](#%E5%8F%97%E4%BF%A1%E5%81%B4%E3%81%AE%E5%AE%9F%E8%A3%85)\n  * [おわりに](#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB)"
    }
  },
  "__N_SSG": true
}
