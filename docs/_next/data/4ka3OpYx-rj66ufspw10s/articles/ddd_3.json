{
  "pageProps": {
    "article": {
      "header": {
        "slug": "ddd_3",
        "matter": {
          "title": "DDDについて（3）",
          "createdAt": "2021-10-20T0001:54.325Z",
          "tags": ["DDD", "Kotlin"]
        },
        "excerpt": "1\\. Entity について 1.1 基本的な定義 Entity は、ドメインにおいて「識別可能（Identity） なオブジェクト」です。 重要なのは「ID を持ち、同じ ID であれば属性が変わっても同じ存在だとみなす」点です。 さらに、エンティティは ドメインの振る舞いを持つ リッチモデルとして実装されることが..."
      },
      "bodyMdText": "\n## 1. Entity について\n\n### 1.1 基本的な定義\n\nEntity は、ドメインにおいて「識別可能（Identity） なオブジェクト」です。\n重要なのは「ID を持ち、同じ ID であれば属性が変わっても同じ存在だとみなす」点です。\nさらに、エンティティは ドメインの振る舞いを持つ リッチモデルとして実装されることが望ましく、単にデータを保持するだけでなく、ビジネスルールをメソッドとして内包します。\n\n### 1.2 VO との違い\n\n- VO（Value Object）\n\n  - 識別子を持たず、属性のすべてが同一なら同一性を判断する。\n\n  - 不変（Immutable）であることが基本。\n\n- Entity（エンティティ）\n\n  - 一意の識別子（ID）を持つ。\n\n  - 属性値が変わっても同一性は ID で判断。\n\n## 2. 識別子（ID）の扱い\n\n### 2.1 識別子を VO として扱う\n\ndata class を使うと、equals / hashCode / toString が自動生成されるため、ID 同士を簡単に比較できます。\n\n```kotlin\n// 普通のデータクラスで ID を表現する例\ndata class OrderId(val value: String) {\n    init {\n        require(value.isNotBlank()) { \"OrderId は空にできません。\" }\n    }\n}\n\ndata class CustomerId(val value: String) {\n    init {\n        // ここでは「UUID として 36 文字」を期待する例\n        require(value.length == 36) { \"CustomerId は UUID (36文字) を期待します。\" }\n    }\n}\n```\n\n### 2.2 識別子生成のパターン\n\nID の生成方法はいくつか種類があり、以下に簡単にまとめます。\n\n#### i. UUID をアプリケーション側で生成\n\n```kotlin\nimport java.util.UUID\n\nclass OrderIdGenerator {\n    fun nextId(): OrderId = OrderId(UUID.randomUUID().toString())\n}\n```\n\n弊チームでは ID は UUID を採用していて、アプリ側で生成するようにしています。このとき、UUID のラッパーとなる VO を作成してその中で生成するのがおすすめです。\n\n#### ii. DB 側で発行\n\nDB 側で ID を自動生成する方法もあります。\n\n#### iii. ナチュラルキー（事業的に一意な値）を ID とする\n\nアプリ上意味のある値を ID にするという方法もあります。（当然一意性は担保される必要はあります）\nですが、アプリの仕様変更などで動かなくなる可能性もあるため注意です。\n\n## 3. equals() / hashCode() の設計\n\n#### 3.1 比較の際は、ID のみで比較する\n\nエンティティでは「ID が同じ」なら同一のオブジェクトとみなします。\nたとえその他の属性（名前やメールアドレスなど）が変わっても、同じ ID であれば同一のエンティティを指します。\n\nただ厄介なのが、kotlin の data class ではデフォルトだとプロパティすべてで比較してしまうため、equals を自前で実装する必要があります。\n\n```kotlin\n// NGな例\ndata class User(\n    val id: CustomerId,\n    var name: String,\n    var email: EmailAddress\n)\n```\n\n```kotlin\n// 正しい実装\n//   equals,hashCodeを自前実装\nclass User(\n    val id: CustomerId,\n    var name: String,\n    var email: EmailAddress\n) {\n    // ID のみで同一性を判断\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is User) return false\n        return this.id == other.id\n    }\n\n    override fun hashCode(): Int {\n        // IDのハッシュコードを返すようにする\n        return id.hashCode()\n    }\n\n    // ドメインロジック例: email を更新する\n    fun changeEmail(newEmail: EmailAddress) {\n        require(newEmail != email) { \"新しいメールアドレスが現在と同じです。\" }\n        email = newEmail\n    }\n}\n```\n\n## 4. 可変性（Mutable）と不変性（Immutable）\n\n### 4.1 Entity は状態を変えられることが原則\n\nEntity は VO とは異なり、値を変えられることが原則です。ただし、以下の注意点があります。\n\n- Entity の状態を変更するメソッド（ドメインロジック）を公開し、直接プロパティを変えてはならない\n  - メソッドを介して変更すれば、不正な値がセットされるのを防げる。\n- プロパティには var を使うような方法もあるが、kotlin において var は実はアンチパターンとする見方もあるため、極力 val を使った方がいい\n\n```kotlin\nclass User private constructor(\n    val id: CustomerId,\n    private var _name: String,\n    private var _email: EmailAddress\n) {\n    // 不変であれば val、可変なら var だが、外部直接変更を避けるため private にする\n    var name: String\n        private set     // 外部からは get しかできず、変更はメソッド経由のみ\n        get() = _name\n\n    var email: EmailAddress\n        private set\n        get() = _email\n\n    // 名前変更のドメインロジック\n    fun changeName(newName: String) {\n        require(newName.isNotBlank()) { \"名前は空にできません。\" }\n        require(newName != _name) { \"新しい名前が現在の名前と同じです。\" }\n        _name = newName\n    }\n\n    // メールアドレス変更のドメインロジック\n    fun changeEmail(newEmail: EmailAddress) {\n        require(newEmail != _email) { \"新しいメールアドレスが現在のものと同じです。\" }\n        _email = newEmail\n    }\n\n    companion object {\n        fun new(...): User {\n            ...\n        }\n\n        fun restore(...): User {\n            ...\n        }\n    }\n\n    // equals / hashCode は省略（前節参照）\n    override fun equals(other: Any?): Boolean { /* ... */ }\n    override fun hashCode(): Int { /* ... */ }\n}\n```\n\n余談ですが、弊チームでは entity は `private constructor` として作成するのをルールとしています。\n実装方法によっては通常の constructor で entity を作成、復元するとルールをすり抜けてしまうことがあるからです。\nそのため、生成時のロジックは `new(生成)`、 `restore(復元)` に閉じ込めて通常の constructor は呼び出さないという決まりにしています。\n\n## 5. ライフサイクル管理と状態遷移\n\nエンティティにはしばしば「ステータス (Status)」や「フラグ」などの状態を持たせ、業務ごとに許可される操作や遷移を制御します。これを正しく設計しないと、ビジネスルールが緩くなりバグを生みやすくなります。\nその際の entity の生成は、先ほども書いた`companion object`のファクトリメソッドを使って生成するのがおすすめです。\n\n```kotlin\nimport java.time.LocalDateTime\n\nenum class UserStatusType { ACTIVE, DEACTIVATED }\n\ndata class UserStatus(\n    val type: UserStatusType,\n    val updatedAt: LocalDateTime\n) {\n    fun isActive() = type == UserStatusType.ACTIVE\n    fun deactivate(): UserStatus {\n        return UserStatus(UserStatusType.DEACTIVATED, LocalDateTime.now())\n    }\n}\n\nclass User private constructor(\n    val id: CustomerId,\n    private var _name: String,\n    private var _email: EmailAddress,\n    private var _status: UserStatus,\n    val createdAt: LocalDateTime\n) {\n    var name: String\n        private set\n        get() = _name\n\n    var email: EmailAddress\n        private set\n        get() = _email\n\n    val status: UserStatus\n        get() = _status\n\n    companion object {\n        // 新規ユーザー作成のファクトリメソッド\n        fun createNewUser(id: CustomerId, name: String, email: EmailAddress): User {\n            require(name.isNotBlank()) { \"名前は空にできません。\" }\n            val now = LocalDateTime.now()\n            // デフォルトはactive\n            val initialStatus = UserStatus(UserStatusType.ACTIVE, now)\n            return User(id, name, email, initialStatus, createdAt = now)\n        }\n    }\n\n    // ドメインロジック：退会\n    fun deactivate() {\n        require(_status.isActive()) { \"すでに退会済みのユーザーです。\" }\n        _status = _status.deactivate()\n    }\n\n    // メールアドレス変更\n    fun changeEmail(newEmail: EmailAddress) {\n        require(newEmail != _email) { \"新しいメールアドレスが現在と同じです。\" }\n        _email = newEmail\n    }\n\n    override fun equals(other: Any?): Boolean { /* ID 比較 */ }\n    override fun hashCode(): Int { /* ID のハッシュ */ }\n}\n```\n\n### 終わりに\n\n今回は entity について書きました。正直他にもドメインイベントのこととか色々書いておきたいんですが、時間かかりそうなので一旦ここまでで。\n次回は永続化層かな、、、repository あたり、、、？\n",
      "tocMdText": "- [1. Entity について](#1-entity-%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)\n  * [1.1 基本的な定義](#11-%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E5%AE%9A%E7%BE%A9)\n  * [1.2 VO との違い](#12-vo-%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84)\n- [2. 識別子（ID）の扱い](#2-%E8%AD%98%E5%88%A5%E5%AD%90id%E3%81%AE%E6%89%B1%E3%81%84)\n  * [2.1 識別子を VO として扱う](#21-%E8%AD%98%E5%88%A5%E5%AD%90%E3%82%92-vo-%E3%81%A8%E3%81%97%E3%81%A6%E6%89%B1%E3%81%86)\n  * [2.2 識別子生成のパターン](#22-%E8%AD%98%E5%88%A5%E5%AD%90%E7%94%9F%E6%88%90%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)\n    + [i. UUID をアプリケーション側で生成](#i-uuid-%E3%82%92%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E5%81%B4%E3%81%A7%E7%94%9F%E6%88%90)\n    + [ii. DB 側で発行](#ii-db-%E5%81%B4%E3%81%A7%E7%99%BA%E8%A1%8C)\n    + [iii. ナチュラルキー（事業的に一意な値）を ID とする](#iii-%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB%E3%82%AD%E3%83%BC%E4%BA%8B%E6%A5%AD%E7%9A%84%E3%81%AB%E4%B8%80%E6%84%8F%E3%81%AA%E5%80%A4%E3%82%92-id-%E3%81%A8%E3%81%99%E3%82%8B)\n- [3. equals() / hashCode() の設計](#3-equals--hashcode-%E3%81%AE%E8%A8%AD%E8%A8%88)\n    + [3.1 比較の際は、ID のみで比較する](#31-%E6%AF%94%E8%BC%83%E3%81%AE%E9%9A%9B%E3%81%AFid-%E3%81%AE%E3%81%BF%E3%81%A7%E6%AF%94%E8%BC%83%E3%81%99%E3%82%8B)\n- [4. 可変性（Mutable）と不変性（Immutable）](#4-%E5%8F%AF%E5%A4%89%E6%80%A7mutable%E3%81%A8%E4%B8%8D%E5%A4%89%E6%80%A7immutable)\n  * [4.1 Entity は状態を変えられることが原則](#41-entity-%E3%81%AF%E7%8A%B6%E6%85%8B%E3%82%92%E5%A4%89%E3%81%88%E3%82%89%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%8E%9F%E5%89%87)\n- [5. ライフサイクル管理と状態遷移](#5-%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB%E7%AE%A1%E7%90%86%E3%81%A8%E7%8A%B6%E6%85%8B%E9%81%B7%E7%A7%BB)\n  * [終わりに](#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB)"
    }
  },
  "__N_SSG": true
}
